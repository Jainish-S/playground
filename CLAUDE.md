# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Vision

This is a **Polyglot Monorepo** designed for learning, experimentation, and knowledge sharing. The goal is to document and demonstrate how software can be managed using git, versioning, tags, and how polyglot microservices work together. Git history is a first-class citizen—commits should be educational and traceable.

## Architecture Overview

### Core Stack
- **Orchestrator:** Moonrepo (task runner with caching)
- **Python Management:** uv (with workspace support)
- **Go Management:** Go Workspaces (`go.work`)
- **Frontend:** Next.js
- **Contracts:** Protobuf/gRPC (cross-language type safety)
- **Deployment:** GitOps with ArgoCD (manifests in `infra/` or `deploy/`)

### Directory Structure (Target)
```
apps/                   # Deployable services
  web-dashboard/        # Next.js frontend
  api-gateway/          # Go (Gin/Fiber) - public entrypoint
  inference-engine/     # Python (FastAPI + ML)
packages/               # Shared libraries
  api-contracts/        # Protobuf definitions
  go-common/            # Shared Go utilities
  py-common/            # Shared Python utilities
infra/                  # Infrastructure: Terraform (k8s), K8s manifests, Docker Compose (local dev)
.moon/                  # Moonrepo configuration
```

### Workspace Files
- `go.work` - Links Go modules
- `pyproject.toml` (root) - uv workspace with single lockfile (`uv.lock`)
- `package.json` (root) - Node workspace

## Commands

### Moonrepo (Primary Task Runner)
```bash
moon run :dev                    # Start all apps
moon run <app>:dev               # Start specific app
moon run :test --touched         # Test only changed services
moon run :docker --touched       # Build Docker images for changed services
moon ci --touched                # CI mode with change detection
```

### Python (uv)
```bash
uv sync                          # Install all dependencies
uv add <package>                 # Add dependency (run from app directory)
uv run pytest                    # Run tests
uv run fastapi dev src/main.py   # Dev server
```

### Go
```bash
go build -o bin/server ./cmd/server
go test ./...
```

## Commit Guidelines

- **No AI attribution in commit messages** (no "Generated by Claude" or similar)
- Commits should be **educational and traceable**—future learners will study the git history
- Use conventional commits when appropriate
- Keep commits atomic and well-documented

## AI Agent Rules

### Document the Learning Path
When implementing features or making changes, include the **exact steps followed** so others can learn. This means:
- Explain *why* a particular approach was chosen
- Document commands run and their purpose
- Commit messages should teach, not just describe

### No Duplicate Documentation
**Before creating any new documentation file:**
1. Search for existing docs: `docs/`, `*.md`, `ARCHITECTURE.md`, `README.md`
2. If relevant documentation exists, **update it in place**—do not create parallel files
3. Only create new docs when the topic is genuinely new and has no existing home

**Common violations to avoid:**
- Creating `SETUP.md` when `README.md` already has setup instructions
- Creating `API.md` when `docs/api.md` exists
- Creating `CONTRIBUTING.md` when contribution guidelines exist elsewhere

### Single Source of Truth
- Each concept/process should be documented in exactly **one place**
- Cross-reference with links rather than duplicating content
- When in doubt, add to an existing file rather than creating a new one

## Development Principles

1. **Context-Based Structure:** Group by function/domain, not just by language
2. **Single Root Lockfile (Python):** All Python apps share `.venv` for IDE integration
3. **Docker Builds from Root:** Python Dockerfiles must use root context to access `uv.lock` and sibling packages
4. **Single-Repo GitOps:** Application code and Kubernetes manifests coexist in this repo (`infra/`)
5. **Trunk-Based Development:** `main` is always deployable (DEV), Git tags (`v*`) for releases

## Git Workflow & Release Strategy

### Single Source of Truth
- **`main` branch** is the single source of truth
- All environments (DEV, QA, PROD) are managed from commits on `main`
- **No long-lived environment branches** - promotes artifact, not code

### Environment Management

#### Tagging Strategy
- **DEV:** Runs from `main` HEAD (automated, tagged with commit SHA in CI)
- **QA:** Release candidate tags `v1.0.0-rc.1`, `v1.0.0-rc.2`, etc.
- **PROD:** Stable release tags `v1.0.0`, `v1.0.1`, etc.

#### Example Flow
```bash
# Dev automatically gets latest main
git push origin main
# CI builds image tagged as: myapp:a1b2c3d (commit SHA)

# Promote to QA for testing
git tag v1.0.0-rc.1
git push origin v1.0.0-rc.1
# CI retags existing image: myapp:v1.0.0-rc.1 (same binary!)

# Promote to PROD after QA approval
git tag v1.0.0
git push origin v1.0.0
# CI retags: myapp:v1.0.0 (exact same binary that passed QA)
```

### Merge Strategy: Rebase Only (Linear History)

**All code integration must use rebase - no merge commits allowed.**

```bash
# Feature branch workflow
git checkout -b feature/payment-endpoint
# ... make commits ...
git fetch origin
git rebase origin/main          # Reapply your commits on top of main
git push --force-with-lease     # Update remote branch
```

**GitHub Settings (Required):**
- ❌ Disable "Create a merge commit"
- ❌ Disable "Squash and merge" (preserves atomic commits)
- ✅ Enable "Rebase and merge" ONLY

**Why Linear History?**
1. Clean, chronological story for learning
2. `git log --oneline` shows single line of commits
3. Easy rollbacks with `git revert`
4. `git bisect` works without merge noise

### Hotfix Workflow (Critical Production Bugs)

**Scenario:** PROD is on `v1.0.0`, but `main` has new unreleased features. A critical bug is found in PROD.

#### Step 1: Branch from the PROD Tag
```bash
git fetch --all --tags
git checkout -b hotfix/payment-null-pointer v1.0.0
# Your code is now exactly as it exists in PROD (no new features)
```

#### Step 2: Fix and Test
```bash
# Write the fix
git add .
git commit -m "fix: prevent null pointer in payment validation"

# Test against the old codebase
moon run api-server:test
```

#### Step 3: Tag the Hotfix for PROD
```bash
git tag v1.0.1
git push origin hotfix/payment-null-pointer
git push origin v1.0.1
# CI builds image from v1.0.1 and deploys to PROD
```

#### Step 4: Rebase the Fix onto Main
**Critical: The bug still exists in `main`! We must prevent regression.**

```bash
git checkout main
git pull --rebase origin main
git checkout hotfix/payment-null-pointer
git rebase main
# Resolve conflicts if new features touched the same code
```

#### Step 5: Integrate via PR
```bash
git push origin hotfix/payment-null-pointer --force-with-lease
# Open PR: hotfix/payment-null-pointer → main
# Merge using "Rebase and merge"
# Delete hotfix branch after merge
```

#### Result: Linear History Preserved
```
* [main] feat: add user dashboard (new feature)
* [main] feat: add metrics endpoint (new feature)
* [v1.0.1] fix: prevent null pointer in payment (hotfix, now in main too)
* [v1.0.0] feat: initial payment API
```

When you eventually release `v2.0.0` with the new features, the hotfix is included automatically.

### Branching Rules Summary

| Branch Type | Created From | Purpose | Lifespan | Integration Method |
|-------------|-------------|---------|----------|-------------------|
| `main` | - | Source of truth | Permanent | - |
| `feature/*` | `main` | New functionality | Hours to days | Rebase onto `main`, PR |
| `hotfix/*` | PROD tag (e.g., `v1.0.0`) | Emergency fixes | Hours | Tag for PROD, then rebase onto `main` |

### Build Once, Deploy Anywhere

**Philosophy:** Never rebuild code for different environments. Promote the same artifact.

1. **Build:** CI builds Docker image when code merges to `main`
2. **Tag:** Same image gets multiple tags (`a1b2c3d`, `v1.0.0-rc.1`, `v1.0.0`)
3. **Promote:** Deployment changes image tag in manifests (`infra/`), not code
4. **Guarantee:** Binary that passed QA is identical to binary running in PROD

### Tag Lifecycle Example

```bash
# Developer merges feature to main
git push origin main
# CI: Build image → myapp:a1b2c3d
# ArgoCD: Deploy a1b2c3d to DEV

# Team lead: Ready for QA
git tag v1.0.0-rc.1
# CI: Tag existing image → myapp:v1.0.0-rc.1 (no rebuild!)
# Update infra/qa/values.yaml image.tag = v1.0.0-rc.1

# QA approves
git tag v1.0.0
# CI: Tag existing image → myapp:v1.0.0 (no rebuild!)
# Update infra/prod/values.yaml image.tag = v1.0.0
```

## Frontend (Next.js + shadcn/ui)

### shadcn/ui Installation (IMPORTANT)
**shadcn/ui is NOT an npm package. It's a CLI that generates component files.**

```bash
# Initialize shadcn in a Next.js project
cd apps/<app-name>
pnpm dlx shadcn@latest init

# Add individual components
pnpm dlx shadcn@latest add button
pnpm dlx shadcn@latest add card
pnpm dlx shadcn@latest add input
```

### What shadcn init does:
1. Creates `components.json` config file
2. Sets up `lib/utils.ts` with `cn()` helper
3. Configures Tailwind CSS with shadcn theme
4. Creates `components/ui/` directory for components

### Key Rules:
- **DO NOT manually install Radix UI packages** - shadcn CLI handles dependencies
- Each component is generated into `components/ui/<component>.tsx`
- Components are fully customizable - you own the code
- Use `pnpm` for package management (not npm/yarn)

### Docs Reference
- Installation: https://ui.shadcn.com/docs/installation/next
- Components: https://ui.shadcn.com/docs/components/button
